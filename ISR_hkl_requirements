## ISR requests that require hkl 
ISR requires HKL to run several diffractometers. Their required capabilities are:

- [ ] Create an ophyd object for the 4 circle diffractometer, which includes a reference to the sample lattice parameters.
- [ ] Create an ophyd object for the psic diffractometer, which includes a reference to the sample lattice parameters.
- [ ] Create an ophyd object for the zeta diffractometer, which includes a reference to the sample lattice parameters.

    - see [this link to the CSX definition](https://github.com/NSLS-II-CSX/xf23id1_profiles/blob/4cd43f2857aa401cd778de1e8309ebf9435ce0af/profile_collection/startup/csx1/startup/tardis.py) as an example. They use the E6C class with a 4 circle difractomer and set the unavailable rotation axes to '0'.
    - setting the sample lattice will be done via
    ```
    # import the lattice object
    from hkl.util import Lattice
    # define the lattice lengths are in Angstrom, angles are in degrees
    lattice = Lattice(a=9.069, b=9.069, c=10.390, alpha=90.0, beta=90.0, gamma=120.0)
    # add the sample to the calculation engine
    hkl_object.calc.new_sample('some_sample_name', lattice=lattice)
    ```

### Requirements for diffractometer `hkl_object`
- [ ] Be able to find the current location in reciprocal-space (hkl) and real-space values.
    - this can be done by the 2 command:
    ```
    hkl_object.position  # reciprocal space position in hkl co-ordinates.
    hkl_object.real_postiion  # real-space position.
    ```
- [ ] Be able to calculate the sample orientation based on a known real_space and reciprocal_space location.
    - The main 'use case' for this is, a reflection (and hence the values of h,k,l) has been found at a defined 'real space' location which does not match the calculated value. This is most likely related to sample 'misalignment' in that one or more of the defined lattice angles is out by some 'offset' value.
    - It has been requested that we provide a method which determines what this mis-alignment is.
    - Note: this is not a current feature of hkl as far as I can tell.
- [ ] Be able to calculate real-space values given the reciprocal-space (hkl) values and vice-versa.
    - This can be done using the built-in hkl methods:
    ```
    hkl_object.calc.wavelength = plancks_constant*speed_of_light/ photon_energy
    hkl_object.calc.forward((h,k,l))  # real-space positions based on inputted h,k,l co-ordinates
    hkl_object.calc.reverse(('mu',  'omega',  'chi',  'phi', 'gamma', 'delta'))  # hkl values from angles
    ```
    - Note 1: We may want to write a custom version of the reverse calculation that is a `partial`of this for the 5 axis diffractometer. along the lines of the following:
    ```
    def hkl_object(hkl.diffract.E6C):

        hkl_object.calc.reverse(value):  # where value = ('mu',  'omega',  'chi',  'phi', 'gamma')
            value.append(0)  # adds a zero for the 'delta' angle
            return super().calc.reverse(value)
    ```
    - Note 2: A similiar version of the above should probably be implemented for the forward calculation that limits the return value to only the known angles.

- [ ] Be able to choose _geometry modes_ for each of the diffractometers (which defines which rotation stages to include in calculations and motions).
    - I am so far not sure on how to approach this, essentially it would mean making the reduction form say a 6 circle diffractometer to a 4 circle diffractomer (by fixing the value of certain axes) changable.
- [ ] Be able to move the diffractometer to a given (hkl) position.
    - This can be done via the following:
    ```
    hkl_object.move(h,k,l)  # move to these 'h,k,l' co-ordinates
    ```
- [ ] Be able to, at a minimum, perform `scan`'s and `grid_scan`'s  in reciprocal space.
    - Note: In addition to scanning in 'reciprocal space' a request for 'energy' scanning with 'fixed Q' has also been made (by ISR).
         - This would involve fixed h,k,l and therefore non- fixed real-space locations (as the h,k,l calculation relies on photon energy).
